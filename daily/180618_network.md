# 180618 TIL (Network)

HTTP & URI 공부 (웹지탱 책 + 구글링)

## URI (Uniform Resource Identifier)

URI란 리소스를 통일적으로 식별하는 ID를 말한다

통일적이란 모두가 같은 규칙을 따르고 있다는 것

식별자란 어떤 것을 그 밖의 다른 것과 구별하여 가리키기 위한 이름/ID를 말한다

http://whale.ocm//entries/1

URI Scheme: http

호스트명: whale.com

패스: /entries/1

**반드시 유일한 호스트명과 유일한 패스를 사용함**으로 전세계의 어느 URI도 중복되지 않게 한다

http://yohai:pass@whale.com:8000/search?q=test&debug=true#n10

URI Scheme: http

사용자정보: yohei:pass

호스트명: whale.com

포트번호: 8000

패스: /search

쿼리 파라미터: q=test&debug=true

URI프래그먼트: #n10



쿼리파라미터는 쿼리 문자열(query string)이라고도 부르며 검색서비스에 검색 키워드를 전달할 때 등 클라이언트에서 동적으로 URI를 생성할 때 사용한다



**Base URI**

명시적으로 지정하는 방법

HTML안에서 명시적으로 Base URI를 지정하는 방법

head요소 안에 base요소를 추가한다



URI에서 사용할 수 있는 문자

알파벳 A-Za-z

숫자 0-9

ㅓ기호 -.~:@!$&'()

ASCII문자다, 이외의 문자를 입력하려고하면 %인코딩 방식을 이용해야 한다

www.whale.com/가 는 인코딩에 의해 www.whale.com/%EA%B0%80이 된다

가는 UTF-8에서 3바이트로 이루어지는 것에 기인한다 %xx 16진수를 사용하는 것이다



**URI구현에서 주의해야할 점들**

- 상대URI의 해석 : 클라이언트에서 상대 URI를 해석하는 것은 번거로운 처리가 필요하기에 가능한한 절대URI사용
- %인코딩을 다룰 때 : 인코딩의 혼란이 오기 때문에 utf-8권장



URI, URL, URN

URI는 URL, URN을 포함하는 총 범위라고 할 수 있다

URL(Uniform Resource Locator)은 우리가 흔히 사용하는 www.whale.com/list/12의  형식이다

URN(Uniform Resource Name)은 URL의 문제점에 대응해 도메인명과는 독립적으로 리소스에 항구적인 ID를 할당하기 위한 스펙으로 나왔다

형식은 urn:isbn:9784774142043과 같다

현재 웹의 가치가 향상됨에 따라 URL이 충분히 영속적이어서 URN을 사용할 필요가 없는 경우가 많다



### URI의 설계

**Cool URI**

좋고 아름다운 URI를 가리키고 팀 버너스 리가 발표한 Cool URIs dont' change라는 웹페이지가 그 기원이다 (변하지 않는 URI가 최고의 URI)

**좀처럼 변하지 않는 URI만들기**

- 특정 언어에 의존적인 확장자와 경로를 포함하지 않는다
  /login.pl 과 /servlet/LoginSevlet는 perl과 java에 언어에 의존적이어서
  언어가 바뀌면 접근 불가다
- 메서드명과 세션ID를 포함하지 않는다
- URI는 리소스를 표현하는 명사로 한다

login form login page에서 form, page도 굳이 필요가없다

=> http://whale.com/login

**Cool URI는 심플한 URI이기도 하다!**

### URI를 강하게 의식하기

URI가 은폐하기도 쉽고 프로그래머가 별로 신경쓰지 않을 수 있다

다음과 같은 점에서 URI는 아주 중요하다

- URI는 리소스의 이름이다
- URI는 수명이 길다
- URI는 브라우저가 어드레스 란에 표시한다



## HTTP

이름이 하이퍼텍스트 전송용 프로토콜이지만 실제로 HTML과 XML같은 하이퍼텍스트 뿐만 아니라 모든 이미지, 음성, 동영상, js프로그램, pdf 등 모든 데이터를 전송할 수 있다

### TCP/IP

**애플리케이션 계층**

HTTP, NTP, SSH, SMTP, DNS

TCP로 프로그램을 만들 때는 소켓이라 불리는 라이브러리를 이용하는 것이 일반적이다

대부분의 프로그래밍 언어에 HTTP를 구현한 라이브러리가 준비되어 있기 때문에 소켓을 사용해 독자적으로 HTTP를 구현할 일은 거의 없다

---

**트랜스포트 계층**

UDP, TCP

IP가 하지 않았던 데이터의 무결성을 보증하는 역할을 한다

TCP는 목적지의 상대에 대해서 커넥션을 연결한다

이 커넥션을 사용해 데이터의 누락을 체크하고 데이터의 도달을 보증한다

어느 애플리케이션으로 전달할지 결정하는 것이 포트번호다 (디폴트는 80번포트)

---

**인터넷 계층**

IP

데이터를 실제로 주고 받음

TCP/IP의 IP가 여기에 해당, 데이터의 기본 통신 단위는 패킷

---

**네트워크 인터페이스 계층**

이더넷

위 4가지 단계는 **계층형 프로토콜**이다



#### HTTP 메세지의 구조

스타트라인 (start line)

헤더 (header)

빈 줄 (blank line) : 헤더의 종료를 빈 줄로 식별한다

바디 (body)



#### HTTP의 스테이트리스성

서버에서 클라이언트의 애플리케이션 상태를 보존하지 않는다는 것이다

햄버거 주문을 할 때에 햄버거 종류에 따라서 순차적으로 메뉴를 골라 나가지만

스테이트리스적으로 한다면 매번 햄버거의 종류와 순차적으로 따라오는 값들을 계속해서 나열해야 하는 비효율적으로 변한다

**스테이트리스를 채택하는 이유**

- 스테이트풀한 아키텍쳐로는 클라이언트의 수가 증가했을 때 규모를 확장하기가 어렵다
- 매번 클라이언트가 자신의 애플리케이션 상태를 전달하기 때문에 서버가 그 많은 클라이언트들의 상태들을 기억할 필요가 없다-> 사람이 많아도 단순히 서버 증설만 하면 된다

**스테이트리스의 결점**

- 퍼포먼스의 저하
  - 송신할 데이터의 양이 많아진다
  - 인증 등 서버에 부하가 걸리는 처리를 반복한다
- 통신 에러에 대한 대처



#### 심플한 프로토콜의 강점

HTTP를 심플하게 유지하기 때문에 비로소 브라우저는 PC뿐만 아니라 그 밖의 다양한 디바이스에서도 구현할 수 있게 되었다

웹 서비스와 웹 API가 같은 프로토콜로 실현될 수 있는 것이다



### HTTP메서드

#### 총 8개의 메서드

너무 적어서 안좋을 것 같지만 HTTP가, 웹이 성공할 수 있었던 이유가 여기에 있다

#### GET

지정한 URI의 정보를 가져온다

GET은 가장 이용 빈도가 높은 메서드다 웹 페이지, 이미지, 동영상 등의 취득을 위해 우리들이 브라우저를 이용할 때는 언제나 수많은 GET을 발행하고 있다

**GET의 예**

요청

```http
GET/list/HTTP/1.1
Host: example.com
```

응답

```http
HTTP/1.1 200 OK
Content-Type: application/json

[
    {"uri":"http://example.com/list/item1"},
    {"uri":"http://example.com/list/item2"},
    {"uri":"http://example.com/list/item3"},
    {"uri":"http://example.com/list/item4"}
]
```



#### POST

POST는 GET다음으로 이용 빈도가 높은 메서드다

POST에는 세 가지 역할이 있다

- 서버 리소스의 작성
- 기존의 리소스에 데이터 추가
- 다른 메서드로는 대응할 수 없는 처리
  (URI가 너무 길어질 때 GET으로는 힘들다 GET의 URI에 있던 키워드를 POST에서는 요청메세지의 body에 넣어서 할 수 있다)



### 스테이터스 코드

- 1xx : 처리중
  처리가 계속되고 있음, 클라이언트는 그대로 요청을 계속하던지 서버의 지시에 따라 프로토콜을 업데이트하여 재전송한다
- 2xx : 성공
  요청이 성공했음
- 3xx : 리다이렉트
  다른 리소스로의 리다이렉트를 나타낸다. 클라이언트는 이 스테이터스코드를 받았을 때 응답메세지의 Location헤더를 보고 새로운 리소스에 접속
- 4xx : 클라이언트 에러
- 5xx : 서버에러
  원인이 서버에 있다 서버 측의 원인이 해결되면 동일한 요청을 재전송하여 정상적인 결과를 얻을 가능성이 있다

스테이터스 코드에서 중요한 점은 이것을 **의미에 맞게 올바르게 사용해야 한다는 점**이다

임의로 용도에 맞지 않게 변경하는 일이 있어서는 안된다



### HTTP 헤더

메세지의 바디에 대한 부가적인 정보, 즉 메타데이터를 표한한다

클라이언트와 서버는 헤더를 보고 메세지에 대한 동작을 결정합니다

크게 일반 헤더(클라이언트, 서버 양쪽 모두 사용), 요청 헤더, 응답 헤더로 나눌 수 있다
