# 180716 Offline

## 자료구조 & 알고리즘

알고리즘도 반복 & 숙달이다 창의보다 외우는 것으로 시작해야 한다

포기만 안하고 한다면 시간이 지나고 반드시 가능하다!

### 알고리즘과 복잡도

> 왜요 라는 것은 좋은 것이다!

왜 알고리즘 실행시간 분석을 "초"로 하지 않는가?

하드웨어가 달라질 때 시간이 달라지기 때문에 "초"로 할 수 없다!

- 공간복잡도 : 내 알고리즘이 얼마나 많은 메모리를 차지하는가?
- 시간복잡도 : 얼마나 시간이 오래걸리는가?

보통 시간복잡도가 중요하다 시간에 따라 앱을 사용할지가 결정된다

공간복잡도는 메모리초과로 답이 안나올 때 고려해야 한다



#### 점근 표기법

- 알고리즘 복잡도를 단순히 표현하기 위해 사용됨
- Big-O 표기법이 가장 널리 사용됨

> 이산 수학 한 번 보기

##### Big-O

Big-O notation은 입력이 많아졌을 때에 cg(n)보다는 어떤 경우보다

빠르다는 것을 증명하는 것이다 = 최악의 성능을 보장해 줌

Big-O가 중요한 것은 최악의 상황을 잡는 것이 중요하기 때문

알고리즘에서 Log가 중요하다!

##### Omega

이 이상으로는 불가능하다는 것을 나타날 때 쓴다

##### Theata

수학적으로 거의 정확하게 매칭될 때만 사용한다



insert(n) -> O(n) 넣어줄 때에 밀어줘야하기 때문

search(n) -> O(n) 전체를 찾아야하기 때문

a[i] -> O(1) start Address + size*index



## Git

git revert c -> c의 상태로 가는 것이 아니라 c를 없애고 그 전의 상태로 돌아간다

git revert HEAD -> 마지막 커밋을 제거하게 된다



## Recursion (재귀)

함수가 함수 안에서 자신을 다시 호출하는 것

다이나믹 프로그래밍의 기초다

```js
function recursion(n) {
    // base case 기본단계
  if (n === 0) {
    console.log('땡');
    return;
  }
    
    // recursive case 재귀단계
  console.log(n);
  recursion(--n);
}
recursion(10);
```

재귀는 항상 종료조건 (base case)을 먼저 생각하고 짜야 한다!



### 분할 정복

문제를 해결하는 방법이다

내가 풀 수 없는 문제를 풀 수 있을만큼 문제를 쪼개고 합치는 방법이다



```js
// Array의 합 구하기
function sumArray(arr) {
  if (arr.length === 0) return 0;
  return arr[0] + sumArray(arr.slice(1));
}
console.log(sumArray([1, 2, 3, 5]));
```

##### 피보나치 수열

f(n) = f(n-1) + f(n-2)

f(5) = f(4) + f(3)

=f(3) +f(2) +f(2) +1

= f(2) + 1 + 1+ 0 + 1 + 0 + 1

=1 + 0 + 1 + 1 + 0 + 1 + 0 + 1

= 5

