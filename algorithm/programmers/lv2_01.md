## No overtime

야근 지수 회사원인 수민이는 많은 일이 쌓여 있습니다. 수민이는 야근을 최소화하기 위해 남은 일의 작업량을 숫자로 메기고, 일에 대한 야근 지수를 줄이기로 결정했습니다. 야근 지수는 남은 일의 작업량을 제곱하여 더한 값을 의미합니다. 수민이는 1시간 동안 남은 일 중 하나를 골라 작업량 1만큼 처리할 수 있습니다. 수민이의 퇴근까지 남은 N 시간과 각 일에 대한 작업량이 있을 때, noOvertime 함수를 제작하여 수민이의 야근 지수를 최소화 한 결과를 출력해 주세요. 예를 들어, N=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 일을 한 결과는 [2, 2, 2]가 되고 야근 지수는 22 + 22 + 22 = 12가 되어 12를 반환해 줍니다.

### My Solution

```js
function noOvertime(no, works) {
    var result = 0;
    // 야근 지수를 최소화 하였을 때의 야근 지수는 몇일까요?
    works = works.sort((a,b)=>b-a);
    while(no >0){
        works[works.indexOf(Math.max(...works))]--;
        no--;
    }
    result = works.reduce((ac,cv)=>{
       ac+= cv*cv
        return ac
    },0)
    return result;
}
```

### Comment

- 우아한 테크캠프 코딩테스트롤 보고 알고리즘은 평소에 꼭 해야함을 느껴서 다시 1일 1알고리즘을 시작했다
- 코딜리티 7레벨부터 너무 어려워서 잠깐 우회하는 시간을 갖기로 했다 근데 여기도 만만치 않은 것 같다
- lv3이라고 만만하게 생각하다가 엄청 오랜 시간이 걸려도 안돼서 포기했었는데 오랜만에 들어와서 이게 될까? 라는 생각으로 해봤는데 정답이 나왔다
- 코딜리티를 하다가 프로그래머스를 하니 복잡도가 사라지니 뭔가 정답이지만 찝찝하다ㅠ.ㅠ